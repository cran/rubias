<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Eric C. Anderson" />

<meta name="date" content="2021-01-15" />

<title>An Explanation of the Underlying Data Structures in rubias</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">An Explanation of the Underlying Data Structures in rubias</h1>
<h4 class="author">Eric C. Anderson</h4>
<h4 class="date">2021-01-15</h4>



<p>In order to be computationally efficient and allow for multiallelic markers, with <code>rubias</code> we boil most of the data down to a bunch of integer vectors in a data structure that we operate on with some compiled code.</p>
<p>This document is intended to document that data structure (mostly for Eric’s benefit, at this point. We should have had a document like this a long time ago).</p>
<div id="the-param_list" class="section level2">
<h2>The <code>param_list</code></h2>
<p>The basic data structure is what we call a <code>param_list</code>. it has the following named elements, which are briefly described here. We will describe each in detail in separate sections below.</p>
<ul>
<li><p><code>L</code>: the number of loci, an integer</p></li>
<li><p><code>N</code>: the number of individuals (integer)<br />
</p></li>
<li><p><code>C</code>: the number of collections in the reference data set (integer)</p></li>
<li><p><code>A</code>: the number of alleles at each locus (integer vector of length L)</p></li>
<li><p><code>CA</code>: the “cumulative number of alleles” at each locus. For each locus this gives the base-0 index of the first allele at the locus (if you were to line all the alleles at each locus up one after another.)</p></li>
<li><p><code>coll</code>: an integer vector of length N that gives the index of the collection that each fish is in.</p></li>
<li><p><code>coll_N</code>: an integer vector of length C that gives the number of fish in each of the collections</p></li>
<li><p><code>RU_vec</code>: This is the hardest one to figure out / remember. Imagine that each collection has an index from 1 up to C, and imagine that each collection belongs to a single reporting unit. Each reporting unit is assigned an integer. Now, sort everything first by reporting unit index and then by collection index. The order that you get is the order of the collections in <code>RU_vec</code>. This vector is a named integer vector. The collections are in the order as described above. The names are the collection names and the values are the base-1 index of each collection.<br />
</p></li>
<li><p><code>RU_starts</code>: The base-0 index of the starting position of each reporting unit in the <code>RU_vec</code> vector. This is a named integer vector. For example, the first few entries of the chinook data set are:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a>ploidies &lt;-<span class="st"> </span><span class="kw">check_refmix</span>(chinook, <span class="dv">5</span>)</span>
<span id="cb1-2"><a href="#cb1-2"></a>cpar &lt;-<span class="st"> </span><span class="kw">tcf2param_list</span>(chinook, <span class="dv">5</span>, <span class="dt">summ =</span> <span class="ot">FALSE</span>, <span class="dt">ploidies =</span> ploidies)</span>
<span id="cb1-3"><a href="#cb1-3"></a>cpar<span class="op">$</span>RU_starts[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>]</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co">#&gt; CentralValleyfa CentralValleysp CentralValleywi CaliforniaCoast        KlamathR </span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">#&gt;               0               8              12              13              15</span></span></code></pre></div>
<p>and if we look at the first 15 elements of <code>RU_vec</code> it gives us the names and the indices of the collections in those first 4 listed reporting units:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>cpar<span class="op">$</span>RU_vec[<span class="dv">1</span><span class="op">:</span><span class="dv">15</span>]</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">#&gt;         Feather_H_sp         Feather_H_fa          Butte_Cr_fa </span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co">#&gt;                    1                    6                    7 </span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">#&gt;           Mill_Cr_fa           Deer_Cr_fa       Mokelumne_R_fa </span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">#&gt;                    8                    9                   10 </span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="co">#&gt;            Battle_Cr      Sacramento_R_lf          Butte_Cr_Sp </span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="co">#&gt;                   11                   12                    2 </span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="co">#&gt;           Mill_Cr_sp           Deer_Cr_sp UpperSacramento_R_sp </span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="co">#&gt;                    3                    4                    5 </span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="co">#&gt;         Sacramento_H                Eel_R            Russian_R </span></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="co">#&gt;                   13                   14                   15</span></span></code></pre></div></li>
<li><p><code>I</code>: an integer vector giving the allelic type of each gene copy carried by each individual. For ploidy = 2 (the only case implemented so far) this vector is of length (N * L * 2). An entry of 0 denotes missing data, and the observed alleles are named 1, 2, …</p></li>
<li><p><code>AC</code>: this is a flat integer vector of the counts of alleles of different types in the different populations. It has length C * sum(A) (i.e. the number of collections in the reference times that total number of alleles at all the loci.). This is created by a somewhat lengthy process: first the function <code>reference_allele_counts()</code> makes a long data frame that has <code>collection</code>, <code>locus</code>, <code>allele</code>, and <code>counts</code>. This then gets turned into a list of matrices in <code>a_freq_list()</code>. One matrix for each collection. The rows are the different alleles and the columns are the different populations. Then in <code>list_diploid_params()</code> that list of matrices gets flattened into one long integer vector.<br />
One of the weaknesses as I see that now, is that the loci are arranged alphabetically, rather than by input order. We should at least include the names of the loci in the order in which they appear so that we can get back to the loci, if necessary. The order of the loci coming out of this process is used to make sure that it corresponds to the order of the loci in <code>I</code>, which is good, but not super intuitive. At any rate, from the foregoing, it can be deduced that we can index into this vector thus (all indexes are base-0): if we want the count of the a-th allele at the l-th locus in the c-th collection then we get that by base-0 subscipting <code>AC</code> by <code>[C * CA[l] + c * A[l] + a].  Where</code>C<code>is the number of collections,</code>CA<code>is the cumulative number of alleles, and</code>A<code>is the number of alleles at each locus. Now it should be clear why we store</code>CA`—this is where we use it!</p></li>
<li><p><code>sum_AC</code>: the sum of the allele counts at each locus for each collection in the reference data set. (Basically the number of observed gene copies at the locus in the reference data set). This gets computed in <code>list_diploid_params()</code> from the list of matrices returned by <code>a_freq_list()</code>. It is of length L * C. It is a named vector with the names taking <code>Locus.Collection</code>, but I don’t think those names get used at all. It gets indexed as <code>[l * C + c]</code></p></li>
<li><p><code>DP</code>: this is a vector completely parallel to <code>AC</code> but in which the prior weights have been added to each allele in each collection.<br />
</p></li>
<li><p><code>sum_DP</code>: this is the sum of Dirichlet Parameters <code>DP</code> for each locus and each collection. It is parallel to <code>sum_AC</code>.</p></li>
</ul>
<p>Finally, we have some entries that we should have had from day one, but didn’t, so they aren’t consistently used throughout the code to access the names of entities ordered as they ended up ordered: - <code>indiv_names</code> - <code>collection_names</code> - <code>repunit_names</code> - <code>locus_names</code></p>
</div>
<div id="howwhere-do-all-these-get-set" class="section level2">
<h2>How/Where do all these get set?</h2>
<p>This is a trickier question than it seems, because things are done slightly differently in the different top-level functions.</p>
<div id="assess_reference_loo-and-assess_reference_mc" class="section level3">
<h3>assess_reference_loo() and assess_reference_mc()</h3>
<p>In both of these functions, the original data sets gets read in, collection and repunit get converted to factors, and then the <code>param_list</code> is made inside a single function: <code>tcf2param_list()</code>.</p>
</div>
<div id="assess_pb_bias_correction" class="section level3">
<h3>assess_pb_bias_correction()</h3>
<p>Same as above, this uses <code>tcf2param_list()</code> after doing a few other steps on the original data frame.</p>
</div>
<div id="self_assign" class="section level3">
<h3>self_assign()</h3>
<p>Uses <code>tcf2param_list()</code> unless it is using preCompiledParams so that it can run through stuff during infer_mixture to compute the locus-specific means and variances of the log-likelihoods.</p>
</div>
<div id="infer_mixture" class="section level3">
<h3>infer_mixture()</h3>
<p>This is the tough one. Because we end up doing multiple mixture collections, we couldn’t simply use <code>tcf2param_list()</code> in the function. Rather, we create a summary for the reference sample (keeping track of alleles found in both the reference and the mixture), and then we split the mixture samples up by mixture collection and use</p>
</div>
</div>
<div id="dealing-with-012-matrices" class="section level2">
<h2>Dealing with 012 matrices</h2>
<p>One problem with the current approach is that it is terribly slow when you start to get 10K+ SNPs. It would be much faster to read and store those data in an 012 matrix. Here is how I am thinking I could deal with that:</p>
<ul>
<li><p>For the functions that use <code>tcf2param_list()</code> I could just write another function, <code>tcf2param_list_012()</code>, that took <code>D</code> as just a data frame with <code>sample_type</code>, <code>collection</code>, and <code>repunit</code> and <code>indiv</code>, and then had an 012 matrix with the genetic data in it, with indiv names in the rownames and locus names in the colnames. Then we just have to deal with seeing AC_list and I_list correctly. <em>Actually</em>, looking at it now, I can just do it in the same <code>tcf2param_list()</code> function. If the <code>d012</code> parameter is not NULL we would:</p>
<ol style="list-style-type: decimal">
<li>make <code>cleaned$long</code> NULL, and set <code>cleaned$clean_short</code> to <code>D</code>.</li>
<li>make the <code>AC_list</code> directly from the 012 matrix. This should be super straightforward. I would probably want to drop monomorphic loci first.</li>
<li>make the I_list from the 012 matrix</li>
</ol></li>
</ul>
<p>Cool, in order to do all this I should make two new functions: <code>reference_allele_counts_012</code> and <code>allelic_list_012</code>. That might give me enough insight that I could easily do it for <code>infer_mixture</code>, too.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
